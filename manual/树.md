# 二叉树
## 遍历
从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点**都被且仅被**访问一次

二叉树遍历次序不同于线性结构，线性结构分为顺序，循环，双向等遍历方式

**树的结点不存在唯一的前驱和后继**，访问一个结点后，下一个结点面临不同选择

遍历方式有很多种，分为
### 前序遍历
二叉树为空，则直接返回，否则先访问根结点，再左子树，再右子树，记为**中-左-右**

一般采用两种方式实现遍历：**递归**和**迭代**

递归三要素：

1. 函数要做什么
2. 寻找递归结束的条件
3. 找出函数的等价关系

递归实现

	class Solution {
		ArrayList<Integer> list = new ArrayList<>();
		public List<Integer> preorderTraversal(TreeNode root) {
			if (root == null) {
				return list;
			}
			
			list.add(root.val);
			
			if (root.left != null) {
				preorderTraversal(root.left);
			}
			
			if (root.right != null) {
				preorderTraversal(root.right);
			}
			
			return list;
		}
	}
迭代实现（使用栈，所以先将根结点的右子结点入栈，再左子结点）

	class Solution {
		public List<Integer> preorderTraversal(TreeNode root) {
			LinkedList<Integer> res = new LinkedList<>();
			LinkedList<TreeNode> stack = new LinkedList<>();
			if (root == null) {
				return res;
			}
			
			stack.add(root);
			
			while (!stack.isEmpty()) {
				TreeNode node = stack.pollLast();
				res.add(node.val);
				
				if (node.right != null) {
					stack.add(node.right);
				}
				
				if (node.left != null) {
					stack.add(node.left);
				}
			}
			
			return res;
		}
	}
### 中序遍历
二叉树为空，则直接返回，否则从根结点开始（注意，不是访问），先左子树，再根结点，再右子树，记为**左-中-右**

同样采用两种方式实现遍历：**递归**和**迭代**

递归实现

	class Solution {
		ArrayList<Integer> list = new ArrayList<>();
		public List<Integer> inorderTraversal(TreeNode root) {
			if (root == null) {
				return list;
			}
			
			if (root.left != null) {
				inorderTraversal(root.left);
			}
			
			list.add(root.val);
			
			if (root.right != null) {
				inorderTraversal(root.right);
			}
			
			return list;
		}
	}
迭代实现（使用栈，内部用一个while循环遍历得到curr结点的最左侧结点，当curr为空时，栈顶的元素就是其子树的根结点，这时弹出栈顶元素并赋值给curr，接着将curr的右子结点赋值给curr，再执行外部while直到栈为空且curr为空）

	class Solution {
		public List<Integer> inorderTraversal(TreeNode root) {
			List<Integer> res = new ArrayList<>();
			Stack<TreeNode> stack = new Stack<>();
			TreeNode curr = root;
			
			while (curr != null || !stack.isEmpty()) {
				while (curr != null) {
					stack.push(curr);
					curr = curr.left;
				}
				curr = stack.pop();
				res.add(curr.val);
				curr = curr.right;
			}
			
			return res;
		}
	}
### 后序遍历
二叉树为空，则直接返回，否则从左到右，先叶子结点后结点的方式遍历访问左右子树，最后访问根结点，记为**左-右-中**

可以采用三种方式实现遍历：**递归**，**迭代**和**取巧**

递归实现

	class Solution {
		ArrayList<Integer> list = new ArrayList<>();
		public List<Integer> postorderTraversal(TreeNode root) {
			if (root == null) {
				return list;
			}
			
			if (root.left != null) {
				postorderTraversal(root.left);
			}
			
			if (root.right != null) {
				postorderTraversal(root.right);
			}
			
			list.add(root.val);
			
			return list;
		}
	}
迭代实现（使用栈，last用于保存当前栈顶弹出的元素，判断curr.right == last是为了避免重复访问同一个元素而陷入死循环）

	class Solution {
		public List<Integer> postorderTraversal(TreeNode root) {
			List<Integer> res = new LinkedList<>();
			Stack<TreeNode> stack = new Stack<>();
			TreeNode curr = root;
			TreeNode last = null;
			
			while (curr != null || !stack.isEmpty()) {
				while (curr != null) {
					stack.push(curr);
					curr = curr.left;
				}
				
				curr = stack.peek(); // peek只是读取不是弹出
				if (curr.right == null || curr.right == last) {
					res.add(curr.val);
					stack.pop();
					last = curr;
					curr = null;
				} else {
					curr = curr.right;
				}
			}
			
			return res;
		}
	}
取巧实现（使用栈，后序遍历的结点访问顺序为左-右-中，将其颠倒后得到中-右-左，再联想到前序遍历的结点访问顺序为中-左-右，因此，可以将前序遍历的压栈顺序进行调整，将其逆序输出即可，逆序就是每次在链表头部进行插入，栈是后进先出的，所以先将左子结点入栈，再右子结点）

	class Solution {
		public List<Integer> preorderTraversal(TreeNode root) {
			LinkedList<Integer> res = new LinkedList<>();
			LinkedList<TreeNode> stack = new LinkedList<>();
			if (root == null) {
				return res;
			}
			
			stack.add(root);
			
			while (!stack.isEmpty()) {
				TreeNode node = stack.pollLast();
				res.addFirst(node.val);
				
				if (node.left != null) {
					stack.add(node.left);
				}
				
				if (node.right != null) {
					stack.add(node.right);
				}
			}
			
			return res;
		}
	}
### 层序遍历
树为空，则直接返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，同一层中，按从左到右的顺序对结点逐个访问

可以采用两种方式实现遍历：**递归**和**迭代**

递归实现

	class Solution {
		List<List<Integer>> res = new ArrayList<List<Integer>>();
		
		public List<List<Integer>> sequenceTraversal(TreeNode root) {
			if (root == null) {
				return res;
			}
			
			helper(root, 0);
			return res;
		}
		
		public void helper(TreeNode root, int level) {
			// level层开始，创建一个当前层的数组并放入res中
			if (res.size() == level) {
				res.add(new ArrayList<Integer>());
			}
			
			res.get(level).add(node.val);
			
			if (node.left != null) {
				helper(node.left, level + 1);
			}
			
			if (node.right != null) {
				helper(node.right, level + 1);
			}
		}
	}
迭代实现，使用队列进行迭代

	class Solution {
		public List<Integer> sequenceTraversal(TreeNode root) {
			List<List<Integer>> res = new LinkedList<>(); // 二维数组，接收每层的结点
			if (root == null) {
				return res;
			}
			
			Queue<TreeNode> q = new LinkedList<>(); // 队列，依次存放每层的结点
			q.add(root);
			
			while (!q.isEmpty()) {
				List<Integer> tmp = new ArrayList<>(); // 临时数组，存放每层的结点
				int len = q.size();
				
				for (int i = 0; i < len; i++) {
					TreeNode node = q.poll();
					tmp.add(node.val);
					
					if (node.left != null) {
						q.add(node.left);
					}
					
					if (node.right != null) {
						q.add(node.right);
					}
				}
				
				res.add(tmp); // 将当前层结点放入res中
			}
			
			return res;
		}
	}